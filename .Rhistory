new_data$frequency=log(new_data$frequency)
hist(new_data$frequency, main="histogram of new_data with log of frequency")
new_data = scale(new_data)
sample = seq(1, 18417, by = 10)
head(sample)
customers_sample = customers[sample, ]
new_data_sample  = new_data[sample, ]
# Compute distance metrics on standardized data
d = dist(new_data_sample)
# Perform hierarchical clustering on distance metrics
c = hclust(d, method="ward.D2")
# Plot de dendogram
plot(c)
# Cut at 5 segments
members = cutree(c, k = 5)
# Show 30 first customers, frequency table
members[1:30]
table(members)
# Show profile of each segment
aggregate(customers_sample[, 2:4], by = list(members), mean)
new_data_sample[c(260,5920),]
new_data_sample[260,]
View(new_data_sample)
data = read.delim(file = 'purchases.txt', header = FALSE, sep = '\t', dec = '.')
colnames(data) = c('customer_id', 'purchase_amount', 'date_of_purchase')
data$date_of_purchase = as.Date(data$date_of_purchase, "%Y-%m-%d")
data$year_of_purchase = as.numeric(format(data$date_of_purchase, "%Y"))
data$days_since       = as.numeric(difftime(time1 = "2016-01-01",
time2 = data$date_of_purchase,
units = "days"))
View(data)
library(sqldf)
customers_2015 = sqldf("SELECT customer_id,
MIN(days_since) AS 'recency',
MAX(days_since) AS 'first_purchase',
COUNT(*) AS 'frequency',
AVG(purchase_amount) AS 'amount'
FROM data GROUP BY 1")
View(customers_2015)
customers_2015$segment = ifelse(test = customers_2015$recency > 365*3, yes = "inactive", no = "NA")
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
customers_2015$segment = ifelse(test = customers_2015$recency > 365*3,
yes = "inactive",
no = ifelse(test = customers_2015$recency > 365*2,
yes = "cold",
no = "NA"))
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
View(customers_2015)
customers_2015$segment = "NA"
customers_2015$segment[which(customers_2015$recency > 365*3)] = "inactive"
customers_2015$segment[which(customers_2015$recency <= 365*3 & customers_2015$recency > 365*2)] = "cold"
customers_2015$segment[which(customers_2015$recency <= 365*2 & customers_2015$recency > 365*1)] = "warm"
customers_2015$segment[which(customers_2015$recency <= 365)] = "active"
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
customers_2015$segment = "NA"
customers_2015$segment[which(customers_2015$recency > 365*3)] = "inactive"
customers_2015$segment[which(customers_2015$recency <= 365*3 & customers_2015$recency > 365*2)] = "cold"
customers_2015$segment[which(customers_2015$recency <= 365*2 & customers_2015$recency > 365*1)] = "warm"
customers_2015$segment[which(customers_2015$recency <= 365)] = "active"
customers_2015$segment[which(customers_2015$segment == "warm" & customers_2015$first_purchase <= 365*2)] = "new warm"
customers_2015$segment[which(customers_2015$segment == "warm" & customers_2015$amount < 100)] = "warm low value"
customers_2015$segment[which(customers_2015$segment == "warm" & customers_2015$amount >= 100)] = "warm high value"
customers_2015$segment[which(customers_2015$segment == "active" & customers_2015$first_purchase <= 365)] = "new active"
customers_2015$segment[which(customers_2015$segment == "active" & customers_2015$amount < 100)] = "active low value"
customers_2015$segment[which(customers_2015$segment == "active" & customers_2015$amount >= 100)] = "active high value"
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
# Re-order factor in a way that makes sense
customers_2015$segment = factor(x = customers_2015$segment, levels = c("inactive", "cold",
"warm high value", "warm low value", "new warm",
"active high value", "active low value", "new active"))
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
customers_2014 = sqldf("SELECT customer_id,
MIN(days_since) - 365 AS 'recency',
MAX(days_since) - 365 AS 'first_purchase',
COUNT(*) AS 'frequency',
AVG(purchase_amount) AS 'amount'
FROM data
WHERE days_since > 365
GROUP BY 1")
customers_2014$segment = "NA"
customers_2014$segment[which(customers_2014$recency > 365*3)] = "inactive"
customers_2014$segment[which(customers_2014$recency <= 365*3 & customers_2014$recency > 365*2)] = "cold"
customers_2014$segment[which(customers_2014$recency <= 365*2 & customers_2014$recency > 365*1)] = "warm"
customers_2014$segment[which(customers_2014$recency <= 365)] = "active"
customers_2014$segment[which(customers_2014$segment == "warm" & customers_2014$first_purchase <= 365*2)] = "new warm"
customers_2014$segment[which(customers_2014$segment == "warm" & customers_2014$amount < 100)] = "warm low value"
customers_2014$segment[which(customers_2014$segment == "warm" & customers_2014$amount >= 100)] = "warm high value"
customers_2014$segment[which(customers_2014$segment == "active" & customers_2014$first_purchase <= 365)] = "new active"
customers_2014$segment[which(customers_2014$segment == "active" & customers_2014$amount < 100)] = "active low value"
customers_2014$segment[which(customers_2014$segment == "active" & customers_2014$amount >= 100)] = "active high value"
customers_2014$segment = factor(x = customers_2014$segment, levels = c("inactive", "cold",
"warm high value", "warm low value", "new warm",
"active high value", "active low value", "new active"))
# Show segmentation results
table(customers_2014$segment)
pie(table(customers_2014$segment), col = rainbow(24))
aggregate(x = customers_2014[, 2:5], by = list(customers_2014$segment), mean)
revenue_2015 = sqldf("SELECT customer_id, SUM(purchase_amount) AS 'revenue_2015'
FROM data
WHERE year_of_purchase = 2015
GROUP BY 1")
summary(revenue_2015)
actual = merge(customers_2015, revenue_2015, all.x = TRUE)
actual$revenue_2015[is.na(actual$revenue_2015)] = 0
# Show average revenue per customer and per segment
aggregate(x = actual$revenue_2015, by = list(customers_2015$segment), mean)
forward = merge(customers_2014, revenue_2015, all.x = TRUE)
forward$revenue_2015[is.na(forward$revenue_2015)] = 0
# Show average revenue per customer and per segment
r = aggregate(x = forward$revenue_2015, by = list(customers_2014$segment), mean)
print(r)
# Re-order and display results
r = r[order(r$x, decreasing = TRUE), ]
print(r)
barplot(r$x, names.arg = r$Group.1)
View(data)
data = read.delim(file = 'purchases.txt', header = FALSE, sep = '\t', dec = '.')
View(data)
colnames(data) = c('customer_id', 'purchase_amount', 'date_of_purchase')
data$date_of_purchase = as.Date(data$date_of_purchase, "%Y-%m-%d")
data$year_of_purchase = as.numeric(format(data$date_of_purchase, "%Y"))
data$days_since       = as.numeric(difftime(time1 = "2016-01-01",
time2 = data$date_of_purchase,
units = "days"))
View(data)
data = read.delim(file = 'purchases.txt', header = FALSE, sep = '\t', dec = '.')
View(data)
data = read.delim(file = 'purchases.txt', header = FALSE, sep = '\t', dec = '.')
View(data)
dim(data)
?dplyr
??dplyr
library(dplyr)
distinct(data)
colnames(data) = c('customer_id', 'purchase_amount', 'date_of_purchase')
data$date_of_purchase = as.Date(data$date_of_purchase, "%Y-%m-%d")
data$days_since       = as.numeric(difftime(time1 = "2016-01-01",
time2 = data$date_of_purchase,
units = "days"))
distinct(data)
View(data)
library("xlsx")
read.xlsx("cleanedRFMData.xlsx", sheetIndex = 1,header = TRUE)
sont<-read.xlsx("cleanedRFMData.xlsx", sheetIndex = 1,header = TRUE)
View(sont)
summary(sont)
str(sont)
sont$date_last_usage = as.Date(sont$date_last_usage, "%Y-%m-%d")
sont$days_since= as.numeric(difftime(time1 = "2016-09-01",
time2 = data$date_last_usage, units                         = "days"))
str(sont)
View(sont)
sont$days_since= as.numeric(difftime(time1 = "2016-09-01",
time2 = data$date_last_usage, units                         = "days"))
sont$days_since= as.numeric(difftime(time1 = "2016-09-01",
time2 = sont$date_last_usage, units                         = "days"))
str(sont)
View(sont)
library(sqldf)
customers = sqldf("SELECT account_id,
MIN(days_since) AS 'recency',
COUNT(*) AS 'frequency',
AVG(amount) AS 'amount'
FROM sont GROUP BY 1")
head(sont)
summary(sont)
hist(customers$recency)
hist(customers$frequency)
hist(customers$amount)
hist(customers$amount, breaks = 100)
hist(customers$amount, breaks = 200)
new_data = customers
head(new_data)
row.names(new_data) = new_data$customer_id
new_data$customer_id = NULL
head(new_data)
View(new_data)
head(new_data)
row.names(new_data) = new_data$account_id
new_data$account_id = NULL
head(new_data)
View(new_data)
new_data$amount = log(new_data$amount)
hist(new_data$amount)
new_data = scale(new_data)
head(new_data)
BullRiders<-read.csv("BullRiders.csv")
View(BullRiders)
library(lattice)
library(datasets)
xyplot(Ozone ~ Wind, data=airquality)
set.seed(10)
x<-rnorm(100)
f<-rep(0:1, each=50)
y<-x + f - f * x + rnorm(100, sd=.5)
f<-factor(f, labels = c("Group 1", "Group 2"))
xyplot(y ~ x | f, layout = c(2,1))
xyplot (y ~ x | f, panel = function(x,y,...){
panel.xyplot(x,y,...)##first call the default panel function for xyplot
panel.lmline(x,y, col=2) ##overlay a simple regression line
})
library(hexbin)
x <- rnorm(1000)
y <- rnorm(1000)
bin<-hexbin(x, y, xbins=50)
plot(bin, main="Hexagonal Binning")
piq <- read.csv("~/Documents/R/piq.csv")
View(piq)
fit <- lm(y ~ x1 + x2 + x3, data=piq)
fit <- lm(y ~ "Brain" + "Height" + "Weight", data=piq)
fit <- lm("PIQ" ~ "Brain" + "Height" + "Weight", data=piq)
fit <- lm(PIQ ~ Brain + Height + Weight, data=piq)
summary(fit) # show results
pairs(~PIQ+Brain+Height+Weight,data=piq,
main=" Scatterplot Matrix")
?attach
library(scatterplot3d)
install.packages("scatterplot3d")
library(scatterplot3d)
scatterplot3d(~PIQ+Brain+Height+Weight,data=piq, main="3D Scatterplot")
Scatterplot Matrix
library(scatterplot3d)
scatterplot3d(PIQ,Brain,Height,Weight,data=piq, main="3D Scatterplot")
attach(piq)
scatterplot3d(PIQ,Brain,Height,Weight,data=piq, main="3D Scatterplot")
library(scatterplot3d)
attach(piq)
scatterplot3d(PIQ,Brain,Height,Weight, main="3D Scatterplot")
plot3d(PIQ,Brain,Height,Weight, main="Spinning Scatterplot")
library(rgl)
plot3d(PIQ,Brain,Height,Weight, main="Spinning Scatterplot")
library(rgl)
plot3d(PIQ,Brain,Height,Weight)
bloodpress <- read.delim("~/Documents/R/bloodpress.txt")
View(bloodpress)
?corr
?cor
vars <-c("Top10_13", "Rides13")
cor(new_bull[,vars])
cor(bloodpress)
bloodpress$Pt = NULL
cor(bloodpress)
str(bloodpress)
attach(bloodpress)
scatterplot3d(BP,Age,Weight,BSA, Dur, Pulse,Stress, main="Bloodpressure")
library(scatterplot3d)
attach(bloodpress)
scatterplot3d(BP,Age,Weight,BSA, Dur, Pulse,Stress, main="Bloodpressure")
scatterplot3d(BP,Age,Weight,Stress, main="Bloodpressure")
str(bloodpress)
fit <- lm(BP ~ Age + Weight + Stress, data=bloodpress)
summary(fit) # show results
library(lattice)
pairs(~BP+Age+Weight+Weight,Stress=bloodpress,
main=" Scatterplot Matrix BP")
IQR(bloodpress$Weight)
iqr(bloodpress)
IQR(bloodpress)
?IQR
hist(bloodpress$Weight)
mean(bloodpress$Weight)
library(lattice)
pairs(~BP+Age+Weight+Weight,Stress=bloodpress,
main=" Scatterplot Matrix BP")
hist(bloodpress$Weight)
mean(bloodpress$Weight)
sd(bloodpress)
library(lattice)
pairs(~BP+Age+Weight+Weight,Stress=bloodpress,
main=" Scatterplot Matrix BP")
hist(bloodpress$Weight)
mean(bloodpress$Weight)
sd(bloodpress$Weight)
SontData <- read.csv("~/Documents/R/SontData.csv")
View(SontData)
SontData <- read.csv("~/Documents/R/SontData.csv")
View(SontData)
sont<-read.csv("SontData.csv")
str(sont)
sont$last_payment_date = as.Date(sont$last_payment_date, "%Y-%m-%d")
sont$year_of_purchase = as.numeric(format(sont$last_payment_date, "%Y"))
sont$days_since= as.numeric(difftime(time1 = "2016-09-01",
time2 = sont$last_payment_date, units = "days"))
str(sont)
summary(sont)
head(sont)
library(sqldf)
customers_2015 = sqldf("SELECT accountID,
MIN(days_since) AS 'recency',
MAX(days_since) AS 'first_purchase',
num_of_pymt AS 'frequency',
avg_pymt_amount AS 'amount'
FROM sont GROUP BY 1")
head(customers_2015)
hist(customers_2015$recency)
hist(customers_2015$frequency)
hist(customers_2015$amount)
hist(customers_2015$amount, breaks = 100)
customers_2015$segment = "NA"
customers_2015$segment[which(customers_2015$recency > 365*3)] = "inactive"
customers_2015$segment[which(customers_2015$recency <= 365*3 & customers_2015$recency > 365*2)] = "cold"
customers_2015$segment[which(customers_2015$recency <= 365*2 & customers_2015$recency > 365*1)] = "warm"
customers_2015$segment[which(customers_2015$recency <= 365)] = "active"
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
customers_2015$segment = ifelse(test = customers_2015$recency > 365*3, yes = "inactive", no = "NA")
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
# A more complex 3-segment solution based on recency alone
customers_2015$segment = ifelse(test = customers_2015$recency > 365*3,
yes = "inactive",
no = ifelse(test = customers_2015$recency > 365*2,
yes = "cold",
no = "NA"))
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
sont<-read.csv("SontData.csv")
str(sont)
sont$last_payment_date = as.Date(sont$last_payment_date, "%Y-%m-%d")
sont$days_since= as.numeric(difftime(time1 = "2016-09-01",
time2 = sont$last_payment_date, units                         = "days"))
str(sont)
library(sqldf)
head(sont)
customers = sqldf("SELECT accountID,
MIN(days_since) AS 'recency',
num_of_pymt AS 'frequency',
avg_pymt_amount AS 'amount'
FROM sont GROUP BY 1")
head(customers)
summary(customers)
hist(customers$recency)
hist(customers$frequency)
hist(customers$amount)
hist(customers$amount, breaks = 100)
hist(customers$amount, breaks = 200)
new_data = customers
head(new_data)
row.names(new_data) = new_data$accountID
new_data$accountID = NULL
head(new_data)
new_data$amount = log(new_data$amount)
hist(new_data$amount)
new_data = scale(new_data)
head(new_data)
d = dist(new_data)
c = hclust(d, method="ward.D2")
plot(c)
members = cutree(c, k = 9)
members[1:30]
table(members)
aggData<-aggregate(new_data[c("recency","frequency","amount")], by=list(members), FUN=mean)
#aggregate(new_data[, 2:4], by = list(members), mean)
aggregate(new_data[, 2:4], by=list(members), FUN=mean)
#aggregate(new_data[, 2:4], by = list(members), mean)
aggregate(new_data[, 2:4], by=list(members), mean)
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
#
data = read.delim(file = 'purchases.txt', header = FALSE, sep = '\t', dec = '.')
# Add headers and interpret the last column as a date, extract year of purchase
colnames(data) = c('customer_id', 'purchase_amount', 'date_of_purchase')
data$date_of_purchase = as.Date(data$date_of_purchase, "%Y-%m-%d")
data$year_of_purchase = as.numeric(format(data$date_of_purchase, "%Y"))
data$days_since       = as.numeric(difftime(time1 = "2016-01-01",
time2 = data$date_of_purchase,
units = "days"))
# Display the data after transformation
head(data)
summary(data)
# Compute key marketing indicators using SQL language
library(sqldf)
# Compute recency, frequency, and average purchase amount
customers_2015 = sqldf("SELECT customer_id,
MIN(days_since) AS 'recency',
MAX(days_since) AS 'first_purchase',
COUNT(*) AS 'frequency',
AVG(purchase_amount) AS 'amount'
FROM data GROUP BY 1")
# Explore the data
head(customers_2015)
summary(customers_2015)
hist(customers_2015$recency)
hist(customers_2015$frequency)
hist(customers_2015$amount)
hist(customers_2015$amount, breaks = 100)
# --- CODING A MANAGERIAL SEGMENTATION ---------------------
#example if statement
x <- 5
if(x > 0){
print("Positive number")
}
x <- 0
if(x > 0){
print("Positive number")
}
#example if else statement
x <- -5
if(x > 0){
print("Non-negative number")
} else {
print("Negative number")
}
#as one line of code
if(x > 0) print("Non-negative number") else print("Negative number")
# Simple 2-segment solution based on recency alone
customers_2015$segment = ifelse(test = customers_2015$recency > 365*3, yes = "inactive", no = "NA")
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
# A more complex 3-segment solution based on recency alone
customers_2015$segment = ifelse(test = customers_2015$recency > 365*3,
yes = "inactive",
no = ifelse(test = customers_2015$recency > 365*2,
yes = "cold",
no = "NA"))
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
# Simple 2-segment solution using the which statement
customers_2015$segment = "NA"
customers_2015$segment[which(customers_2015$recency > 365*3)] = "inactive"
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
# More complex 4-segment solution using which
customers_2015$segment = "NA"
customers_2015$segment[which(customers_2015$recency > 365*3)] = "inactive"
customers_2015$segment[which(customers_2015$recency <= 365*3 & customers_2015$recency > 365*2)] = "cold"
customers_2015$segment[which(customers_2015$recency <= 365*2 & customers_2015$recency > 365*1)] = "warm"
customers_2015$segment[which(customers_2015$recency <= 365)] = "active"
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
# Complete segment solution using which, and exploiting previous test as input
customers_2015$segment = "NA"
customers_2015$segment[which(customers_2015$recency > 365*3)] = "inactive"
customers_2015$segment[which(customers_2015$recency <= 365*3 & customers_2015$recency > 365*2)] = "cold"
customers_2015$segment[which(customers_2015$recency <= 365*2 & customers_2015$recency > 365*1)] = "warm"
customers_2015$segment[which(customers_2015$recency <= 365)] = "active"
customers_2015$segment[which(customers_2015$segment == "warm" & customers_2015$first_purchase <= 365*2)] = "new warm"
customers_2015$segment[which(customers_2015$segment == "warm" & customers_2015$amount < 100)] = "warm low value"
customers_2015$segment[which(customers_2015$segment == "warm" & customers_2015$amount >= 100)] = "warm high value"
customers_2015$segment[which(customers_2015$segment == "active" & customers_2015$first_purchase <= 365)] = "new active"
customers_2015$segment[which(customers_2015$segment == "active" & customers_2015$amount < 100)] = "active low value"
customers_2015$segment[which(customers_2015$segment == "active" & customers_2015$amount >= 100)] = "active high value"
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
# Re-order factor in a way that makes sense
customers_2015$segment = factor(x = customers_2015$segment, levels = c("inactive", "cold",
"warm high value", "warm low value", "new warm",
"active high value", "active low value", "new active"))
table(customers_2015$segment)
aggregate(x = customers_2015[, 2:5], by = list(customers_2015$segment), mean)
# --- SEGMENTING A DATABASE RETROSPECTIVELY ----------------
# Compute key marketing indicators using SQL language
library(sqldf)
# Compute recency, frequency, and average purchase amount
customers_2014 = sqldf("SELECT customer_id,
MIN(days_since) - 365 AS 'recency',
MAX(days_since) - 365 AS 'first_purchase',
COUNT(*) AS 'frequency',
AVG(purchase_amount) AS 'amount'
FROM data
WHERE days_since > 365
GROUP BY 1")
# Complete segment solution using which, and exploiting previous test as input
customers_2014$segment = "NA"
customers_2014$segment[which(customers_2014$recency > 365*3)] = "inactive"
customers_2014$segment[which(customers_2014$recency <= 365*3 & customers_2014$recency > 365*2)] = "cold"
customers_2014$segment[which(customers_2014$recency <= 365*2 & customers_2014$recency > 365*1)] = "warm"
customers_2014$segment[which(customers_2014$recency <= 365)] = "active"
customers_2014$segment[which(customers_2014$segment == "warm" & customers_2014$first_purchase <= 365*2)] = "new warm"
customers_2014$segment[which(customers_2014$segment == "warm" & customers_2014$amount < 100)] = "warm low value"
customers_2014$segment[which(customers_2014$segment == "warm" & customers_2014$amount >= 100)] = "warm high value"
customers_2014$segment[which(customers_2014$segment == "active" & customers_2014$first_purchase <= 365)] = "new active"
customers_2014$segment[which(customers_2014$segment == "active" & customers_2014$amount < 100)] = "active low value"
customers_2014$segment[which(customers_2014$segment == "active" & customers_2014$amount >= 100)] = "active high value"
# Re-order factor in a way that makes sense
customers_2014$segment = factor(x = customers_2014$segment, levels = c("inactive", "cold",
"warm high value", "warm low value", "new warm",
"active high value", "active low value", "new active"))
# Show segmentation results
table(customers_2014$segment)
pie(table(customers_2014$segment), col = rainbow(24))
aggregate(x = customers_2014[, 2:5], by = list(customers_2014$segment), mean)
# --- COMPUTING REVENUE GENERATION PER SEGMENT -------------
# Compute how much revenue is generated by segments
# Notice that people with no revenue in 2015 do NOT appear
revenue_2015 = sqldf("SELECT customer_id, SUM(purchase_amount) AS 'revenue_2015'
FROM data
WHERE year_of_purchase = 2015
GROUP BY 1")
summary(revenue_2015)
# Merge 2015 customers and 2015 revenue (the wrong way)
actual = merge(customers_2015, revenue_2015)
# Merge 2015 customers and 2015 revenue (correct)
actual = merge(customers_2015, revenue_2015, all.x = TRUE)
actual$revenue_2015[is.na(actual$revenue_2015)] = 0
# Show average revenue per customer and per segment
aggregate(x = actual$revenue_2015, by = list(customers_2015$segment), mean)
# Merge 2014 customers and 2015 revenue (correct)
forward = merge(customers_2014, revenue_2015, all.x = TRUE)
forward$revenue_2015[is.na(forward$revenue_2015)] = 0
# Show average revenue per customer and per segment
r = aggregate(x = forward$revenue_2015, by = list(customers_2014$segment), mean)
print(r)
# Re-order and display results
r = r[order(r$x, decreasing = TRUE), ]
print(r)
barplot(r$x, names.arg = r$Group.1)
